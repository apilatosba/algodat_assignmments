\documentclass{article}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{tikz}
\usepackage{array}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}

\begin{document}

\section*{\huge Homework Sheet 11}
\begin{flushright}
  \begin{tabular}{@{} l l l @{}}
    \textbf{Author} & \textbf{Matriculation Number} & \textbf{Tutor} \\
    Abdullah Oğuz Topçuoğlu         & 7063561 & Maryna Dernovaia \\
    Ahmed Waleed Ahmed Badawy Shora & 7069708 & Jan-Hendrik Gindorf \\
    Yousef Mostafa Farouk Farag     & 7073030 & Thorben Johr \\
  \end{tabular}
\end{flushright}

% Please note: An exercise that asks you to design or implement an algorithm is to be answered by (1) your
% algorithm in pseudocode, (2) a correctness proof, and (3) a running time analysis.
% Exercise 1 (Shortest Paths) 6+6 points
% Consider the following weighted directed graph. Note that it does not contain negative-weight cycles.
% 1 2
% 3 4
% 5
% 6 7
% 3
% −1
% 0
% −1
% 3
% −3
% 5
% 2
% −4 5
% 4
% 3
% a. Run the Bellman-Ford algorithm to compute the shortest path distances from 1 to all other
% nodes. Give the state of the array d[1, . . . , 7] after each iteration over all edges. Process edges in
% lexicographic order. That is, consider the edges in the order (1,2), (1,3), (1,4), (2,4), (3,7), (4,3),
% (4,6), (5,7), (6,2), (6,5), (6,7), (7,2).
% b. Since this graph contains edges of negative weight, we do not expect Dijkstra’s algorithm to
% work. Nevertheless, run Dijkstra’s algorithm on this graph from node 1. Give the state of the
% array d[1, . . . , 7] after each iteration. Compare the result to the output of Bellman-Ford’s algorithm,
% and convince yourself that the output is indeed wrong.
% Exercise 2 (Urgent Delivery) 9 points
% Let G = (V, E, w) be a directed weighted graph with nonnegative edge weights, where the nodes model
% cities, the edges model streets and the weights model the travelling times of the streets. Imagine that
% you are running a delivery company with exactly three clients located in cities s1, s2, and s3. Design
% an O((m + n)log n) algorithm that, given G, s1, s2, and s3, computes a city t that minimizes the
% delivery time to the furthest client.
% 1
% Exercise 3 (Snakes and Ladders) 9 points
% The game “Snakes and Ladders” is played on a board with n fields labeled 1, 2, . . . , n. See Figure 1 for
% an instance with n = 100 where we arranged the fields row-by-row. In addition, on the board there
% are snakes and ladders connecting arbitrary fields to each other. A snake is a pair (i, j) with i > j
% (the head and tail of the snake) and a ladder is a pair (i, j) with i < j (the bottom and top of the
% ladder). Let S, L denote the sets of snakes and ladders respectively. The goal of the game is to move
% from field 1 to field n, by the following rules:
% ■ If you are standing on field i and there is a snake (i, j) ∈ S (with its head on i), then you must
% move to j (the tail of the snake).
% ■ If you are standing on field i and there is a ladder (i, j) ∈ L (with its bottom on i), you may move
% to j (the top of the ladder).
% ■ Otherwise, move to i + 1.
% Design an algorithm to compute the smallest number of steps to move from 1 to n on a given Snakes
% and Ladders board. Your algorithm should run in time O(n + |S| + |L|).
% Exercise 4 (Shortest Shortest Paths) 5+5 points
% Let G = (V, E, w) be a weighted graph with positive integer edge weights. Recall that while we often
% speak about “the shortest path” between nodes s and t, there can be several shortest paths. Let Pst
% denote the set of shortest paths from s to t.
% a. Design an O((m + n)log n) algorithm to return a path from Pst with the smallest-possible number
% of edges.
% b. Design an O((m + n)log n) algorithm to return a path from Pst with the largest-possible number
% of edges.
% Hint: Define new edge weights w
% ′
% (e) and run a shortest path algorithm with respect to the weights w
% ′
% .
% Figure 1: Illustrates an instance of Snakes and Ladders for n = 100 (where the fields are nicely
% arranged). For this board, the best solution is to move 1, . . . , 4, 14, . . . , 28, 76, . . . , 80, 99, 100.
% https://www.ymimports.com/pages/how-to-play-snakes-and-ladders

\section*{Exercise 1}
\subsection*{a) Bellman--Ford Algorithm}

\paragraph{Initialization}
\[
d^{(0)} = [0,\infty,\infty,\infty,\infty,\infty,\infty].
\]

Since $|V|=7$, Bellman--Ford performs $6$ iterations.

\paragraph{Iteration 1}
\[
d^{(1)} = [0,3,-2,-1,7,2,2].
\]

\paragraph{Iteration 2}
\[
d^{(2)} = [0,3,-2,-1,7,2,1].
\]

\paragraph{Iteration 3}
\[
d^{(3)} = [0,3,-2,-1,7,2,1].
\]

\paragraph{Iteration 4}
\[
d^{(4)} = [0,3,-2,-1,7,2,1].
\]

\paragraph{Iteration 5}
\[
d^{(5)} = [0,3,-2,-1,7,2,1].
\]

\paragraph{Iteration 6}
\[
d^{(6)} = [0,3,-2,-1,7,2,1].
\]

\paragraph{Final Bellman--Ford Distances}
\[
\boxed{d = [0,3,-2,-1,7,2,1]}.
\]

%-------------------------------------------------

\subsection*{b) Dijkstra’s Algorithm}

Although the graph contains negative-weight edges, we nevertheless execute Dijkstra’s algorithm
from source node $1$.

\paragraph{Initialization}
\[
d = [0,\infty,\infty,\infty,\infty,\infty,\infty].
\]

\paragraph{Iteration 1 (settle node 1)}
\[
d = [0,3,-1,0,\infty,\infty,\infty].
\]

\paragraph{Iteration 2 (settle node 3)}
\[
d = [0,3,-1,0,\infty,\infty,2].
\]

\paragraph{Iteration 3 (settle node 4)}
\[
d = [0,3,-1,0,\infty,3,2].
\]

\paragraph{Iteration 4 (settle node 7)}
\[
d = [0,3,-1,0,\infty,3,2].
\]

\paragraph{Iteration 5 (settle node 2)}
Relaxing $(2,4)$ would improve the distance to node $4$, but node $4$ has already been settled.
Thus no update occurs.

\paragraph{Iteration 6 (settle node 6)}
\[
d = [0,3,-1,0,8,3,2].
\]

\paragraph{Iteration 7 (settle node 5)}
No improvement occurs.

\paragraph{Final Dijkstra Distances}
\[
\boxed{d = [0,3,-1,0,8,3,2]}.
\]

%-------------------------------------------------

\subsection*{Comparison}

\[
\begin{array}{c|c|c}
\text{Node} & \text{Bellman--Ford} & \text{Dijkstra} \\
\hline
1 & 0 & 0 \\
2 & 3 & 3 \\
3 & -2 & -1 \\
4 & -1 & 0 \\
5 & 7 & 8 \\
6 & 2 & 3 \\
7 & 1 & 2
\end{array}
\]

The distances computed by Dijkstra’s algorithm differ from the correct shortest-path distances
found by Bellman--Ford. This confirms that Dijkstra’s algorithm fails on graphs with negative-weight
edges, even when no negative-weight cycles are present.

\section*{Exercise 2}
\begin{verbatim}
    MinimizeFurthestDelivery(G, s1, s2, s3):
    //we return the distance array from running Dijkstra and save it to d1,d2, d3 respectively
      d1 = Dijkstra(G, s1)  
      d2 = Dijkstra(G, s2)
      d3 = Dijkstra(G, s3)

      best = infinity
      t = 0  

      for each v in V:
          temp = max(d1[v], d2[v], d3[v])
          if temp < best:
              best = temp
              t = v

      return t

\end{verbatim}
\paragraph{Correctness Proof}

We show that the algorithm returns a city $t$ that minimizes the delivery time to the furthest client.

Since all edge weights in $G$ are nonnegative, Dijkstra’s algorithm correctly computes shortest-path
distances. Therefore, for each $i \in \{1,2,3\}$ and for every vertex $v \in V$, the value $d_i[v]$
computed by the algorithm equals the minimum travel time from $s_i$ to $v$.

For any vertex $v \in V$, the delivery time to the furthest client located at $s_1, s_2, s_3$ is
\[
M(v) = \max\{ d(s_1,v), d(s_2,v), d(s_3,v) \}.
\]

The algorithm explicitly computes $M(v)$ for each vertex $v$ and maintains a variable \texttt{best}
that stores the smallest value of $M(v)$ seen so far, together with the corresponding vertex $t$.
After the loop terminates, \texttt{best} equals
\[
\min_{v \in V} M(v),
\]
and the stored vertex $t$ satisfies
\[
t = \arg\min_{v \in V} \max\{ d(s_1,v), d(s_2,v), d(s_3,v) \}.
\]

Hence, the algorithm returns a city that minimizes the delivery time to the furthest client and is
therefore correct. 


\paragraph{Runtime Analysis}

Each call to Dijkstra’s algorithm runs in $O((m+n)\log n)$ time.
The algorithm runs Dijkstra three times, which results in a total time of
\[
O((m+n)\log n).
\]

The final loop iterates once over all vertices and performs constant-time operations per vertex,
which takes $O(n)$ time. This does not affect the asymptotic running time.



\section*{Exercise 3}
We will traverse the board using BFS and thats it. The board is a directed graph. The ladders and snakes create edges between the nodes and we have edges between
consecutive nodes if there is no snake head at that node. Assuming the board data is given as two lists (snakes and latters) and a number n for grid size, we will first
create a graph and then run BFS on it. \\
\textbf{Pseudocode:} \\
\begin{verbatim}
  int SmallestNumberOfSteps(int n, list of (int, int) snakes, list of (int, int) ladders)
    // Create graph
    graph G
    for i from 1 to n do
      G.addNode(i)

    for i from 1 to n-1 do
        G.addEdge(i, i+1) // if there is a snake head, we will remove the edge below
    for each (i, j) in snakes do
      if G.hasEdge(i, i+1) then
        G.removeEdge(i, i+1)
      G.addEdge(i, j)
    for each (i, j) in ladders do
      G.addEdge(i, j)  // assuming ladders can't be on the same cells as snakes

    // BFS
    queue Q
    array visited // initially all false
    array distance // initially all infinity
    Q.enqueue(1)
    visited.add(1)
    distance[1] = 0

    while not Q.isEmpty() do
      current = Q.dequeue()
      for each neighbor in G.getNeighbors(current) do
        if neighbor not in visited then
          visited.add(neighbor)
          distance[neighbor] = distance[current] + 1
          Q.enqueue(neighbor)

    return distance[n]
\end{verbatim}

\textbf{Correctness:} \\
In the graph representation the "the smallest number of steps to move from 1 to n" is equivalent to finding the shortest path from node 1 to node n.
BFS is guaranteed to find the shortest path in an unweighted graph. Since each move from one node to another is considered as one step, BFS will correctly compute the smallest number of steps required to reach node n from node 1.

\textbf{Running Time Analysis:} \\
Creating the graph takes O(n + \(|S|\) + \(|L|\)) time.
Running BFS takes O(n + m) time, where m is the number of edges in the graph. In our case, m is at most O(n + \(|S|\) + \(|L|\)) since each node can have edges to its next node, and additional edges from snakes and ladders.
Thus, the overall time complexity of the algorithm is O(n + \(|S|\) + \(|L|\)).
\section*{Exercise 4}
\textbf{a)} \begin{verbatim}
    W'(u,v):
      return (n+1) * w(u,v) +1
    Relax (u,v):
      if d[u] + w'(u,v) < d[v]
         d[v] = d[u] + w'(u,v)
         partent[v] = u
    Algo (node s):
       Dijkstra s
\end{verbatim}
\textbf{b)} 
\begin{verbatim}
    W'(u,v):
      return (n+1) * w(u,v) - 1
    Relax (u,v):
      if d[u] + w'(u,v) < d[v]
         d[v] = d[u] + w'(u,v)
         partent[v] = u
    Algo (node s):
       Dijkstra s
\end{verbatim}
\paragraph{Correctness Proof}

Let $G=(V,E,w)$ be a graph with positive integer edge weights and let $n=|V|$.
Let $d(s,t)$ denote the shortest-path distance from $s$ to $t$ with respect to $w$.

\subparagraph{Part (a): Minimum number of edges}

Define modified edge weights
\[
w'(u,v) = (n+1)\cdot w(u,v) + 1.
\]

For any path $P$,
\[
\sum_{e\in P} w'(e)
= (n+1)\sum_{e\in P} w(e) + |P|.
\]

Since all edge weights are positive integers, if two paths $P_1$ and $P_2$ satisfy
\[
\sum w(P_1) > \sum w(P_2),
\]
then
\[
\sum w(P_1) \ge \sum w(P_2) + 1.
\]

Any simple path contains at most $n-1$ edges, hence
\[
|P_1| - |P_2| \ge -(n-1).
\]

Therefore,
\[
\sum w'(P_1) - \sum w'(P_2)
\ge (n+1)\cdot 1 - (n-1) > 0.
\]

Thus, minimizing total weight with respect to $w'$ implies minimizing total weight with respect to $w$.
Among all shortest paths, the first term is constant, so minimizing $w'$ is equivalent to minimizing $|P|$.
Since $w'(e)>0$ for all edges, Dijkstra's algorithm correctly finds such a path.

\subparagraph{Part (b): Maximum number of edges}

Define modified edge weights
\[
w'(u,v) = (n+1)\cdot w(u,v) - 1.
\]

For any path $P$,
\[
\sum_{e\in P} w'(e)
= (n+1)\sum_{e\in P} w(e) - |P|.
\]

By the same argument as in part (a), minimizing $w'$ enforces
\[
\sum w(P) = d(s,t).
\]

Among all shortest paths, minimizing $\sum w'(P)$ is equivalent to maximizing $|P|$.
Moreover,
\[
w'(u,v) \ge (n+1)\cdot 1 - 1 = n \ge 1,
\]
so all modified weights are positive and Dijkstra’s algorithm applies.

\paragraph{Runtime Analysis}

Computing modified weights takes $O(m)$ time.
Running Dijkstra’s algorithm with a binary tree takes
\[
O((m+n)\log n).
\]


\end{document}
