\documentclass{article}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{tikz}
\usepackage{array}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}

\begin{document}

\section*{\huge Homework Sheet 8}
\begin{flushright}
  \begin{tabular}{@{} l l l @{}}
    \textbf{Author} & \textbf{Matriculation Number} & \textbf{Tutor} \\
    Abdullah Oğuz Topçuoğlu         & 7063561 & Maryna Dernovaia \\
    Ahmed Waleed Ahmed Badawy Shora & 7069708 & Jan-Hendrik Gindorf \\
    Yousef Mostafa Farouk Farag     & 7073030 & Thorben Johr \\
  \end{tabular}
\end{flushright}

% --------------------------------------------------------------------
% ----------------------------- EXERCISE 1 ---------------------------
% --------------------------------------------------------------------

\section*{Exercise 1 (Coin Flips)}

\begin{enumerate}[label=\textbf{\alph*.}]

% (a)
\item \textbf{}

This is deterministic. She always stops after exactly $n$ flips.
\[
\mathbb{E}[T] = n.
\]

% (b)
\item \textbf{}

Let $T$ be the time of the first head. This is a geometric random variable with success probability $p=\tfrac12$:
\[
\mathbb{E}[T] = \frac{1}{p} = 2.
\]

% (c)
\item \textbf{}

This is the negative-binomial stopping time for $n$ successes with success probability $p=\tfrac12$:
\[
\mathbb{E}[T] = \frac{n}{p} = 2n.
\]

% (d)
\item \textbf{}

Let $E_0,E_1,E_2$ denote the expected remaining flips given that the current run of consecutive tails has length $0,1,2$.  
We stop when we reach a run of $3$ tails, so $E_3=0$.

We set up recurrences:
\[
\begin{aligned}
E_0 &= 1 + \tfrac12 E_1 + \tfrac12 E_0,\\[4pt]
E_1 &= 1 + \tfrac12 E_2 + \tfrac12 E_0,\\[4pt]
E_2 &= 1 + \tfrac12 \cdot 0 + \tfrac12 E_0.
\end{aligned}
\]

Solving these:
\[
E_2 = 1 + \tfrac12 E_0, \qquad
E_0 = 2 + E_1.
\]
Substitute into the equation for $E_1$:
\[
E_1 = 1 + \tfrac12(1 + \tfrac12 E_0) + \tfrac12 E_0
     = \tfrac32 + \tfrac34 E_0.
\]
Thus,
\[
E_0 = 2 + \tfrac32 + \tfrac34 E_0
\quad\Rightarrow\quad
E_0 - \tfrac34 E_0 = \tfrac74
\quad\Rightarrow\quad
E_0 = 14.
\]

Hence the expected number of flips until three consecutive tails appear is
\[
\mathbb{E}[T] = 14.
\]

\end{enumerate}

% --------------------------------------------------------------------
% ----------------------------- EXERCISE 3 ---------------------------
% --------------------------------------------------------------------

\section*{Exercise 3}

\begin{verbatim}
void Permute(A[1..n])
   if (n == 1) return
   int randomIndex = rand(n) // rand() function from the lecture
   swap(A[1], A[randomIndex])
   Permute(A[2..n])
\end{verbatim}

\textbf{Correctness Proof:} \\
We prove by induction that the algorithm produces a uniform random permutation of the array $A[1..n]$.

\textbf{Base Case:} For $n = 1$, there is only one permutation. The algorithm returns the array unchanged.

\textbf{Inductive Step:} Assume the algorithm produces a uniformly random permutation for arrays of size $k-1$.  
For size $k$, the algorithm selects a random index from $1$ to $k$, placing each element in the first position with probability $1/k$.  
Then it recursively permutes the remaining $k-1$ elements uniformly by the induction hypothesis.  
Thus the resulting permutation is uniform.

\textbf{Running Time:}
\[
T(1)=1,\qquad T(n)=T(n-1)+1,
\]
so the running time is
\[
T(n) = O(n).
\]

% --------------------------------------------------------------------
% ----------------------------- EXERCISE 4 ---------------------------
% --------------------------------------------------------------------
\section*{Exercise 4}
\begin{enumerate}
    \item 
\begin{verbatim}
Corrupted(A[(x1,y1), (x2,y2) .... (xn,yn)])
   for i := 1,2,... n:
      for j := i + 1, ... n:
         a := (A[i].second - A[j].second) / (A[i].first - A[j].first)
         b := A[i].second - a * A[i].first
         count := 0
         for k := 1, 2 ,...n:
            if A[k].second = a * A[k].first + b:
              count := count + 1
            if count >= n/2+1:
              return (a,b)
\end{verbatim}
\textbf{Correctness Proof:}

We are given that at least $\frac{n}{2} + 1$ of the input points 
$(x_i, y_i)$ are non--corrupted, meaning that for these points
\[
y_i = ax_i + b
\]
for the true underlying coefficients $a,b$.  

\medskip
\noindent
\textit{(1) If the algorithm outputs $(a,b)$, then it is the correct line.}

The algorithm returns $(a,b)$ only if the computed line
\[
y = ax + b
\]
agrees with at least $\frac{n}{2}+1$ of the points.  
By assumption, the true line agrees with at least $\frac{n}{2}+1$ points 
(the non--corrupted ones).  
Any incorrect line can agree with at most $\frac{n}{2}$ points, since 
there are fewer than $\frac{n}{2}$ corrupted points.  
Therefore, if a line agrees with $\frac{n}{2}+1$ points, it must be the
unique correct line.  
Hence, whenever the algorithm returns $(a,b)$, the returned line is correct.

\medskip
\noindent
\textit{(2) The algorithm is guaranteed to find the correct line.}

Since more than half of the points are non--corrupted, there exist at least
\[
\binom{\frac{n}{2}+1}{2}
\]
distinct pairs $(i,j)$ of non--corrupted points.  
For any such pair, the algorithm computes
\[
a = \frac{y_j - y_i}{x_j - x_i}, \qquad 
b = y_i - ax_i,
\]
which are exactly the true coefficients of the underlying line.  
When the algorithm checks this line against all $n$ points, it will find 
at least $\frac{n}{2}+1$ matches and therefore return the correct pair
$(a,b)$.  
Thus, because the algorithm examines \emph{all} pairs $(i,j)$, it is certain
to eventually test a pair of non--corrupted points and return the correct line.

\medskip
\noindent
\text{Therefore, the algorithm always returns the correct coefficients $(a,b)$.}

\bigskip
\textbf{Time Analysis:}

The algorithm consists of three nested loops.  
The outer two loops iterate over all pairs $(i,j)$ with $1 \le i < j \le n$,
which is
\[
\sum_{i=1}^n (n-i)
= \frac{n(n-1)}{2}
= O(n^2)
\]
pairs.  
For each pair, the algorithm checks all $n$ points to count how many lie on the
candidate line, which takes $O(n)$ time.

Thus, the total running time is
\[
O(n^2) \cdot O(n) = O(n^3).
\]

\medskip
\noindent
\textbf{Therefore, the overall running time of the algorithm is $O(n^3)$.}
\item\begin{verbatim}
CorruptedRand(A[(x1,y1), (x2,y2) .... (xn,yn)])
     while true:    
         i:= Rand(n)
         j:= Rand(n)
         if i != j:
           a := (A[i].second - A[j].second) / (A[i].first - A[j].first)
           b := A[i].second - a * A[i].first
           count := 0
           for k := 1, 2 ,...n:
              if A[k].second = a * A[k].first + b:
                count := count + 1
              if count >= n/2+1:
                return (a,b)
         
\end{verbatim}
\textbf{Correctness Proof:}

We are given that at least $\frac{n}{2}+1$ of the input points 
$(x_i,y_i)$ satisfy the true linear relation
\[
y_i = ax_i + b,
\]
while the remaining points may be arbitrary.  

\medskip
\noindent
\textit{(1) If the algorithm outputs $(a,b)$, then the output is correct.}

The algorithm returns $(a,b)$ only when the line $y=ax+b$ agrees with 
at least $\frac{n}{2}+1$ points in the input.  
By assumption, the true line agrees with all non--corrupted points, and there are at least 
$\frac{n}{2}+1$ such points.  
Conversely, any incorrect line can agree with at most the number of corrupted points, which is 
strictly less than $\frac{n}{2}$.  
Therefore, a line that matches $\frac{n}{2}+1$ or more points must be the unique correct line.
Hence the algorithm can only return the correct coefficients.

\medskip
\noindent
\textit{(2) The algorithm finds the correct line with constant probability on each iteration.}

On each recursive iteration, the algorithm chooses two indices $i$ and $j$ independently and uniformly
at random from $\{1,\dots,n\}$.  
Since more than half the points are non--corrupted, the probability that both chosen points 
are non--corrupted is
\[
p \;=\; 
\frac{\frac{n}{2}+1}{n} \cdot \frac{\frac{n}{2}}{n-1}
\;=\;
\Theta(1).
\]
If both points are non--corrupted, then the computed values
\[
a = \frac{y_j - y_i}{x_j - x_i}, \qquad
b = y_i - ax_i,
\]
are exactly the true coefficients of the underlying line.  
In this case the line agrees with all non--corrupted points and therefore 
with at least $\frac{n}{2}+1$ points.  
Thus the algorithm will return $(a,b)$ and terminate.

\smallskip
If one or both of the chosen points are corrupted, the line constructed is incorrect and cannot
agree with $\frac{n}{2}+1$ points.  
In this case the algorithm rejects the line and repeats the process.  
Because the probability of success on each iteration is a positive constant $p$, 
the expected number of iterations before success is 
\[
\mathbb{E}[\text{iterations}] = \frac{1}{p} = O(1).
\]

\medskip
\noindent
Thus the randomized algorithm always returns the correct line and succeeds in a constant expected number of iterations.

\bigskip
\textbf{Time Analysis:}

Each iteration of the algorithm performs the following work:

\begin{itemize}
    \item randomly selects two indices $i$ and $j$, which takes $O(1)$ time;
    \item computes $a$ and $b$, which takes $O(1)$ time;
    \item scans all $n$ points to check how many lie on the resulting line, which takes $O(n)$ time.
\end{itemize}

Thus each iteration costs $O(n)$ time.  
Since the algorithm succeeds with constant probability on each iteration, the expected number of 
iterations before termination is $O(1)$.  
Therefore, the total expected running time is
\[
O(1) \cdot O(n) = O(n).
\]

\medskip
\noindent
\textbf{Hence the randomized algorithm runs in expected time $O(n)$}.

\end{enumerate}

\end{document}
