\documentclass{article}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{tikz}
\usepackage{array}
\usepackage{mathtools}
\usepackage{enumitem}

\begin{document}
\section*{\huge Homework Sheet 3}
\begin{flushright}
  \begin{tabular}{@{} l l @{}}
    \textbf{Authors} & \textbf{Tutors} \\
    Abdullah Oğuz Topçuoğlu & Maryna Dernovaia \\
    Ahmed Waleed Ahmed Badawy Shora & Jan-Hendrik Gindorf \\
    Yousef Mostafa Farouk Farag&
    Thorben Johr \\
  \end{tabular}
\end{flushright}

% Please note: An exercise that asks you to design an algorithm is to be answered by (1) your
% algorithm in pseudocode, (2) a correctness proof, and (3) a running time analysis.
% Exercise 1 (More Lists) 4+4 points
% a. Design an algorithm for the operation Concat(List A, List B) which concatenates the two
% given doubly linked lists A and B in time O(1).
% b. Augment our list implementation to also maintain the size (i.e. the number of elements in the
% list). More precisely, adapt the data structure and implement an operation Size() that returns the
% current size of the list in time O(1). Adapt the operations InsertAfter(Element x, Handle p),
% Remove(Handle p) and Concat(List A, List B) to still run in time O(1).
% Exercise 2 (Stability) 3+3+3 points
% Determine for each of the algorithms InsertionSort, SelectionSort, and MergeSort that we
% saw in the lecture whether they are stable or not. Justify your answer. For the algorithms that are
% not stable, can you find stable variants?
% Exercise 3 (Sorting Points) 12 points
% A grid point is a point p = (x, y) whose coordinates x and y are integers. We call the points (x−1, y),
% (x + 1, y), (x, y − 1), and (x, y + 1) the neighbors of p. A set S of grid points is connected if for every
% ∅ ⊂ S
% ′ ⊂ S there are p1 ∈ S
% ′ and p2 ∈ S \ S
% ′
% such that p1 is a neighbor of p2.
% For this exercise you are given an array A[1..n] whose elements are grid points. We assume that
% A stores a connected set of n grid points. (We also assume that each coordinate of each grid point fits
% in one memory cell.) Design an algorithm that sorts A lexicographically in time O(n). This means
% that we want to sort the grid points in A first by their x-coordinate and as a tie breaker by their
% y-coordinate.
% Exercise 4 (Sorting Strings) 11(+5) points
% For this exercise, a string is an array S[1, . . . , ℓ] consisting of ℓ lower case English letters. You can
% assume that the i-th letter of the alphabet {a, . . . , z} is encoded by the number i. You are given an
% array A of n strings and the goal is to sort them lexicographically. This means we compare strings
% with respect to the usual alphabetical order, e.g. a < ab < b.
% 1
% a. Suppose all strings have the same length ℓ ≥ 1. Design an algorithm to sort A in time O(nℓ).
% b. (5 bonus points) Now suppose each string A[i] has some length ℓi ≥ 1, and these are not necessarily
% all the same (unlike in the previous task). Design an algorithm to sort A in time O(n+m), where
% m =
% Pn
% i=1 ℓi
% is the total length of all strings. You can assume that the lengths ℓ1, . . . , ℓn are part
% of the input.

\section*{Exercise 3}
We can do something similar to LsdRadix sort we saw in the lecture. \\
\textbf{Pseduocode:}
\begin{verbatim}
    function SortGridPoints(A[1..n]) {
        redefine key(point) := point.y
        CountingSort(A)

        redefine key(point) := point.x
        CountingSort(A)
    }
\end{verbatim}

\textbf{Correctness:}
\begin{itemize}
    \item The first CountingSort sorts the points by their y coordinates.
    \item The second CountingSort sorts the points by their x coordinates, but since CountingSort is stable, the order of points with the same x coordinate is preserved.
    \item Therefore after both sorts the points are sorted lexicographically by (x, y).
    \item Thats also what we did in the lecture for LSDRadixSort we started from the least significant digit to the most significant digit. The same idea applies here.
\end{itemize}

\textbf{Running Time Analysis:}
\begin{itemize}
    \item Each CountingSort runs in time O(n + k) where k is the range of the keys.
    \item Here the keys are the x and y coordinates of the points.
    \item Since the points are connected, the range of x coordinates is at most n and the range of y coordinates is also at most n.
    \item Therefore each CountingSort runs in time O(n + n) = O(n).
    \item Since we perform two CountingSorts, the total running time is O(n) + O(n) = O(n).
\end{itemize}

\section*{Exercise 4}
\subsection*{(a)}
We can use the LSDRadixSort again. \\
\textbf{Pseudocode:}
\begin{verbatim}
    function SortStrings(A[1..n], length) {
        for i in length..1 {
            redefine key(string) := string[i]
            CountingSort(A)
        }
    }
\end{verbatim}

\textbf{Correctness:}
\begin{itemize}
    \item We sort the strings starting from the last character to the first character (least significant to most significant).
    \item Each CountingSort is stable, so the order of strings with the same character at position i is preserved.
    \item Therefore after sorting by all character positions, the strings are sorted lexicographically.
    \item So just like LSDRadixSort we saw in the lecture where d is alphabet size, U is the alphabet
\end{itemize}

\textbf{Running Time Analysis:}
\begin{itemize}
    \item Each CountingSort runs in time O(n + k) where k is the range of the keys.
    \item Here the keys are the english letters 'a' to 'z', so k = 26.
    \item Therefore each CountingSort runs in time O(n + 26) = O(n).
    \item Since we perform CountingSort 26 times, the total running time is O(26 * n) = O(n).
\end{itemize}

\subsection*{(b)}
The idea is i will try to convert this problem to the one we solved in part (a). I will treat every word as if they have the same length which is the maximum length of the strings in the input
And then i will introduce a special character for non existent characters in the shorter strings that will come before 'a' in the alphabet.
So that when we sort the strings lexicographically the shorter strings will come before the longer strings with the same prefix. So i change the alphabet to be \{\#, a, b, ..., z\} where \# is the special character. \\

\textbf{Pseudocode:}
\begin{verbatim}
    function SortStringsVariableLength(A[1..n], lengths[1..n]) {
        maxLength = 0
        for i in 1..n {
            if lengths(i) > maxLength {
                maxLength = lengths(i)
            }
        }

        for i in maxLength..1 {
            if i > length(string) {
                redefine key(string) := '#'
            } else {
                redefine key(string) := string[i]
            }

            CountingSort(A)
        }
    }
\end{verbatim}

\textbf{Correctness:} \\
We proved this in part (a) already.

\textbf{Running Time Analysis:}
\begin{itemize}
    \item Finding the maximum length takes O(n) time.
    \item Each CountingSort runs in time O(n + k) where k is the range
    \item Here the keys are the english letters 'a' to 'z' plus the special character '\#', so k = 27.
    \item Therefore each CountingSort runs in time O(n + 27) = O(n).
    \item Since we perform CountingSort maxLength times, the total running time is O(maxLength * n + n) = O(m + n) = O(m) where m is the total length of all strings.
\end{itemize}

\end{document}