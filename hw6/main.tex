\documentclass{article}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{tikz}
\usepackage{array}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}

\begin{document}
\section*{\huge Homework Sheet 6}
\begin{flushright}
  \begin{tabular}{@{} l l l @{}}
    \textbf{Author} & \textbf{Matriculation Number} & \textbf{Tutor} \\
    Abdullah Oğuz Topçuoğlu         & 7063561 & Maryna Dernovaia \\
    Ahmed Waleed Ahmed Badawy Shora & 7069708 & Jan-Hendrik Gindorf \\
    Yousef Mostafa Farouk Farag     & 7073030 & Thorben Johr \\
  \end{tabular}
\end{flushright}

% Please note: An exercise that asks you to design or implement an algorithm is to be answered
% by (1) your algorithm in pseudocode, (2) a correctness proof, and (3) a running time analysis.
% Exercise 1 (Heaps?) 7 points
% For each of the following arrays A[1..12], draw the corresponding binary tree implicitly represented by
% A. In each case mark the vertices that violate the max-heap property and determine whether the
% tree is a heap, a near-heap†
% , or not a heap. If it is a near-heap, then draw the steps of a Heapify
% operation.
% a. A = [17, 15, 17, 13, 6, 12, 10, 1, 5, 3, 1, 11].
% b. A = [4, 14, 13, 3, 8, 12, 11, 2, 2, 5, 7, 2]
% c. A = [20, 10, 12, 9, 8, 3, 10, 13, 10, 15, 3, 7].
% Exercise 2 (Almost Optimal Priority Queue) 4 points
% On the last exercise sheet we proved that for every comparison-based data structure supporting the
% operations Insert, DeleteMax, and Max, at least one of these operations requires worst-case time
% Ω(log n). In the lecture we have seen that heaps support Insert and DeleteMax in worst-case time
% O(log n) and Max in worst-case time O(1).
% Show that for heaps the operations Insert, DeleteMax, and Max run in amortized time
% O(log n), O(1), and O(1), respectively.
% Exercise 3 (k-th largest Element) 9 points
% You are given an array A[1..n] with comparable elements as well as an integer 1 ≤ k ≤ n. Design an
% algorithm that returns the k-th largest element in time O(n + k log n). Formally, you should return
% an element x contained in A such that at most k − 1 elements in A are strictly larger than x and at
% most n − k elements in A are strictly smaller than x.
% Exercise 4 (Running Median) 10 points
% The median of an array B[1..m] is the element which would occur at position ⌈m/2⌉ after sorting the
% array B[1..m]. For example, the median of the array [1, 8, 2, 5, 4] is 4.
% †By near-heap we mean v-near-heap for some node v.
% 1
% You are given an array A[1..n] with comparable elements. Your goal is to compute the median of
% the first ℓ entries of A, for each ℓ. More precisely, design an algorithm that runs in time O(n log n)
% and outputs an array R[1..n] such that for each position ℓ the entry R[ℓ] stores the median of A[1..ℓ].
% Hint: Build R from start to finish and maintain two binary heaps of almost equal sizes.
% Exercise 5 (Train Station Planning) 10 points
% Suppose you want to build a new train station. One of the many things that you need to determine is
% the number of platforms the train station should have. For this, you have access to the list L[1..n]
% of trains that will use this new train station. For each train, you are given its planned arrival and
% departure time at the new station; of course, there will not be any delays. Each train needs to be
% assigned to one platform, and two trains can be assigned to the same platform if the earlier departs
% before the later arrives. As the space for your new train station is limited, you want to build as few
% platforms as possible. Design an algorithm that, given L as input, determines the minimal number of
% platforms in time O(n log n).

\section*{Exercise 1}

\subsection*{(a)}
We are given the array
\begin{align*}
  A = [17, 15, 17, 13, 6, 12, 10, 1, 5, 3, 1, 11].
\end{align*}

The heap tree would be
\begin{center}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=0.75cm}]
  \node {17}
    child {node {15}
      child {node {13}
        child {node {1}}
        child {node {5}}}
      child {node {6}
        child {node {3}}
        child {node {1}}}}
    child {node {17}
      child {node {12}
        child {node {11}}}
      child {node {10}}};
\end{tikzpicture}
\end{center}

This is a heap since all nodes satisfy the max heap property.

\subsection*{(b)}
We are given the array
\begin{align*}
  A = [4, 14, 13, 3, 8, 12, 11, 2, 2, 5, 7, 2].
\end{align*}

The heap tree would be
\begin{center}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=0.75cm}]
  \node {4}
    child {node {14}
      child {node {3}
        child {node {2}}
        child {node {2}}}
      child {node {8}
        child {node {5}}
        child {node {7}}}}
    child {node {13}
      child {node {12}
        child {node {2}}}
      child {node {11}}};
\end{tikzpicture}
\end{center}

This is a near heap because only the root node (4) vioaltes the max heap property. Every other node satisfies it. \\
Steps of heapify operation:

\begin{center}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=0.75cm}]
  \node {14}
    child {node {4}
      child {node {3}
        child {node {2}}
        child {node {2}}}
      child {node {8}
        child {node {5}}
        child {node {7}}}}
    child {node {13}
      child {node {12}
        child {node {2}}}
      child {node {11}}};
\end{tikzpicture}
\end{center}

\begin{center}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=0.75cm}]
  \node {14}
    child {node {8}
      child {node {3}
        child {node {2}}
        child {node {2}}}
      child {node {4}
        child {node {5}}
        child {node {7}}}}
    child {node {13}
      child {node {12}
        child {node {2}}}
      child {node {11}}};
\end{tikzpicture}
\end{center}

\begin{center}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=0.75cm}]
  \node {14}
    child {node {8}
      child {node {3}
        child {node {2}}
        child {node {2}}}
      child {node {7}
        child {node {5}}
        child {node {4}}}}
    child {node {13}
      child {node {12}
        child {node {2}}}
      child {node {11}}};
\end{tikzpicture}
\end{center}

\subsection*{(c)}
We are given the array
\begin{align*}
  A = [20, 10, 12, 9, 8, 3, 10, 13, 10, 15, 3, 7].
\end{align*}

The heap tree would be
\begin{center}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=0.75cm}]
  \node {20}
    child {node {10}
      child {node {9}
        child {node {13}}
        child {node {10}}}
      child {node {8}
        child {node {15}}
        child {node {3}}}}
    child {node {12}
      child {node {3}
        child {node {7}}}
      child {node {10}}};
\end{tikzpicture}
\end{center}

This is not a heap also not a near heap because multiple nodes violate the max heap property. For example the node with the value 9 and the node with the value 8
both violates the max heap property and they are not descendants of each other.

\section*{Exercise 3}
We are gonna use the same approach that we used in the lecture. We will build a max heap from the given array and then we will call
DeleteMax() k many times.

\begin{verbatim}
  int KthLargestElement(A[1..n], k)
    BuildMaxHeap(A)
    for i = 1 to k do
      result = DeleteMax(A)
    return result

  void BuildMaxHeap(A[1..n]) // this is called makeheap() in the lecture slides
    for i = n/2 down to 1 do
      Heapify(A, i) // heapify function from the lecture
\end{verbatim}

\textbf{Running Time Analysis:} \\
Building the max heap takes O(n) time as we saw in the lecture. Each call to DeleteMax() takes O(log n) time. Since we are calling DeleteMax() k many times, this part takes O(k log n) time. Therefore the total running time of the algorithm is
\begin{align*}
  O(n) + O(k \log n) = O(n + k \log n).
\end{align*}

\textbf{Correctness Proof}: \\
The BuildMaxHeap() function builds a valid max heap from the given array A. In a max heap the maximum element is always at the root node. The DeleteMax() function removes and returns the maximum element from the heap and then reestablishes the max heap property by calling Heapify().
So at the time we call DeleteMax() for the kth time we get the kth largest element from the original array A and then we return it.

\section*{Exercise 4}
We will maintain two heaps: a max heap Hlow to store the lower half of the elements and a min heap Hhigh to store the upper half of the elements.
The max heap Hlow will allow us to efficiently retrieve the maximum element of the lower half. The min heap Hhigh will allow us to retrieve the minimum element of the upper half.
\begin{verbatim}
  int[] RunningMedian(A[1..n])
    Hlow = new MaxHeap()
    Hhigh = new MinHeap() // the difference is the comparison function
    R = new int[1..n]
    for i = 1..n do
      if Hlow.isEmpty() or A[i] <= Hlow.Max() then
        Hlow.Insert(A[i])
      else
        Hhigh.Insert(A[i])

      // Balance the heaps
      if Hlow.size() > Hhigh.size() + 1 then
        Hhigh.Insert(Hlow.DeleteMax())
      else if Hhigh.size() > Hlow.size() then
        Hlow.Insert(Hhigh.DeleteMin())

      // Calculate median
      // either they are equal size or Hlow has one more element
      if Hlow.size() == Hhigh.size() then
        R[i] = Hhigh.Min()
      else
        R[i] = Hlow.Max()
    return R
\end{verbatim}
\textbf{Running Time Analysis:} \\
Each insertion into a heap takes O(log m) tim  where m is the number of elements in the heap. Since we are inserting n elements the total time for insertions is O(n log n). Balancing the heaps involves at most one deletion and one insertion, which also takes O(log n) time. Since we do this for each of the n elements, the total time for balancing is also O(n log n). Calculating the median takes O(1) time for each element, resulting in O(n) time for all n elements. Therefore, the overall time complexity of the algorithm is O(n log n). \\

\textbf{Correctness Proof}: \\
The algorithm maintains two heaps to keep track of the lower and upper halves of the elements seen so far. By ensuring that the sizes of the heaps differ by at most one, we can determine the median after each insertion. If the heaps are of equal size, the median is the minimum of the upper half (Hhigh). If Hlow has one more element than Hhigh, the median is the maximum of the lower half (Hlow). This approach guarantees that we always have access to the median in O(1) time after each insertion, and thus correctly computes the running median for each prefix of the array A.

\section*{Exercise 5}
Assume train struct looks like this:
\begin{verbatim}
  struct Train {
    int arrivalTime;
    int departureTime;
  };
\end{verbatim}
The idea is to sort the arrival and departure times of the trains separately and then use two pointers to traverse these sorted lists.

\begin{verbatim}
  int MinPlatforms(Train L[1..n])
    arrivalTimes = new int[1..n]
    departureTimes = new int[1..n]

    for i = 1 to n do
      arrivalTimes[i] = L[i].arrivalTime
      departureTimes[i] = L[i].departureTime

    sort(arrivalTimes) // O(n log n)
    sort(departureTimes) // O(n log n)

    platformNeeded = 0
    maxPlatforms = 0
    i = 1 // pointer for arrivalTimes
    j = 1 // pointer for departureTimes

    while i <= n and j <= n do
      if arrivalTimes[i] < departureTimes[j] then
        platformNeeded++
        maxPlatforms = max(maxPlatforms, platformNeeded)
        i++
      else
        platformNeeded--
        j++

    return maxPlatforms
\end{verbatim}
\textbf{Running Time Analysis:} \\
Sorting the arrival and departure times takes O(n log n) time each (for example assume MergeSort() we have seen in the lecture). The while loop runs in O(n) time since each pointer (i and j) traverses the list of trains once. Therefore the overall time complexity of the algorithm is O(n log n). \\
\textbf{Correctness Proof}: \\
The algorithm sorts the arrival and departure times of the trains, allowing us to process events in chronological order. By using two pointers, we can track the number of platforms needed at any given time. When a train arrives before the next train departs, we need an additional platform. Conversely when a train departs before the next train arrives, we can free up a platform. The maximum number of platforms needed at any point during this process gives us the minimum number of platforms required for the train station.


\end{document}