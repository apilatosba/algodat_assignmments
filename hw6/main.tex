\documentclass{article}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{tikz}
\usepackage{array}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}

\begin{document}
\section*{\huge Homework Sheet 6}
\begin{flushright}
  \begin{tabular}{@{} l l l @{}}
    \textbf{Author} & \textbf{Matriculation Number} & \textbf{Tutor} \\
    Abdullah Oğuz Topçuoğlu         & 7063561 & Maryna Dernovaia \\
    Ahmed Waleed Ahmed Badawy Shora & 7069708 & Jan-Hendrik Gindorf \\
    Yousef Mostafa Farouk Farag     & 7073030 & Thorben Johr \\
  \end{tabular}
\end{flushright}

% Please note: An exercise that asks you to design or implement an algorithm is to be answered
% by (1) your algorithm in pseudocode, (2) a correctness proof, and (3) a running time analysis.
% Exercise 1 (Heaps?) 7 points
% For each of the following arrays A[1..12], draw the corresponding binary tree implicitly represented by
% A. In each case mark the vertices that violate the max-heap property and determine whether the
% tree is a heap, a near-heap†
% , or not a heap. If it is a near-heap, then draw the steps of a Heapify
% operation.
% a. A = [17, 15, 17, 13, 6, 12, 10, 1, 5, 3, 1, 11].
% b. A = [4, 14, 13, 3, 8, 12, 11, 2, 2, 5, 7, 2]
% c. A = [20, 10, 12, 9, 8, 3, 10, 13, 10, 15, 3, 7].
% Exercise 2 (Almost Optimal Priority Queue) 4 points
% On the last exercise sheet we proved that for every comparison-based data structure supporting the
% operations Insert, DeleteMax, and Max, at least one of these operations requires worst-case time
% Ω(log n). In the lecture we have seen that heaps support Insert and DeleteMax in worst-case time
% O(log n) and Max in worst-case time O(1).
% Show that for heaps the operations Insert, DeleteMax, and Max run in amortized time
% O(log n), O(1), and O(1), respectively.
% Exercise 3 (k-th largest Element) 9 points
% You are given an array A[1..n] with comparable elements as well as an integer 1 ≤ k ≤ n. Design an
% algorithm that returns the k-th largest element in time O(n + k log n). Formally, you should return
% an element x contained in A such that at most k − 1 elements in A are strictly larger than x and at
% most n − k elements in A are strictly smaller than x.
% Exercise 4 (Running Median) 10 points
% The median of an array B[1..m] is the element which would occur at position ⌈m/2⌉ after sorting the
% array B[1..m]. For example, the median of the array [1, 8, 2, 5, 4] is 4.
% †By near-heap we mean v-near-heap for some node v.
% 1
% You are given an array A[1..n] with comparable elements. Your goal is to compute the median of
% the first ℓ entries of A, for each ℓ. More precisely, design an algorithm that runs in time O(n log n)
% and outputs an array R[1..n] such that for each position ℓ the entry R[ℓ] stores the median of A[1..ℓ].
% Hint: Build R from start to finish and maintain two binary heaps of almost equal sizes.
% Exercise 5 (Train Station Planning) 10 points
% Suppose you want to build a new train station. One of the many things that you need to determine is
% the number of platforms the train station should have. For this, you have access to the list L[1..n]
% of trains that will use this new train station. For each train, you are given its planned arrival and
% departure time at the new station; of course, there will not be any delays. Each train needs to be
% assigned to one platform, and two trains can be assigned to the same platform if the earlier departs
% before the later arrives. As the space for your new train station is limited, you want to build as few
% platforms as possible. Design an algorithm that, given L as input, determines the minimal number of
% platforms in time O(n log n).

\section*{Exercise 1}

\subsection*{(a)}
We are given the array
\begin{align*}
  A = [17, 15, 17, 13, 6, 12, 10, 1, 5, 3, 1, 11].
\end{align*}

The heap tree would be
\begin{center}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=0.75cm}]
  \node {17}
    child {node {15}
      child {node {13}
        child {node {1}}
        child {node {5}}}
      child {node {6}
        child {node {3}}
        child {node {1}}}}
    child {node {17}
      child {node {12}
        child {node {11}}}
      child {node {10}}};
\end{tikzpicture}
\end{center}

This is a heap since all nodes satisfy the max heap property.

\subsection*{(b)}
We are given the array
\begin{align*}
  A = [4, 14, 13, 3, 8, 12, 11, 2, 2, 5, 7, 2].
\end{align*}

The heap tree would be
\begin{center}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=0.75cm}]
  \node {4}
    child {node {14}
      child {node {3}
        child {node {2}}
        child {node {2}}}
      child {node {8}
        child {node {5}}
        child {node {7}}}}
    child {node {13}
      child {node {12}
        child {node {2}}}
      child {node {11}}};
\end{tikzpicture}
\end{center}

This is a near heap because only the root node (4) vioaltes the max heap property. Every other node satisfies it. \\
Steps of heapify operation:

\begin{center}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=0.75cm}]
  \node {14}
    child {node {4}
      child {node {3}
        child {node {2}}
        child {node {2}}}
      child {node {8}
        child {node {5}}
        child {node {7}}}}
    child {node {13}
      child {node {12}
        child {node {2}}}
      child {node {11}}};
\end{tikzpicture}
\end{center}

\begin{center}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=0.75cm}]
  \node {14}
    child {node {8}
      child {node {3}
        child {node {2}}
        child {node {2}}}
      child {node {4}
        child {node {5}}
        child {node {7}}}}
    child {node {13}
      child {node {12}
        child {node {2}}}
      child {node {11}}};
\end{tikzpicture}
\end{center}

\begin{center}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=0.75cm}]
  \node {14}
    child {node {8}
      child {node {3}
        child {node {2}}
        child {node {2}}}
      child {node {7}
        child {node {5}}
        child {node {4}}}}
    child {node {13}
      child {node {12}
        child {node {2}}}
      child {node {11}}};
\end{tikzpicture}
\end{center}

\subsection*{(c)}
We are given the array
\begin{align*}
  A = [20, 10, 12, 9, 8, 3, 10, 13, 10, 15, 3, 7].
\end{align*}

The heap tree would be
\begin{center}
\begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=6cm},
  level 2/.style={sibling distance=3cm},
  level 3/.style={sibling distance=1.5cm},
  level 4/.style={sibling distance=0.75cm}]
  \node {20}
    child {node {10}
      child {node {9}
        child {node {13}}
        child {node {10}}}
      child {node {8}
        child {node {15}}
        child {node {3}}}}
    child {node {12}
      child {node {3}
        child {node {7}}}
      child {node {10}}};
\end{tikzpicture}
\end{center}

This is not a heap also not a near heap because multiple nodes violate the max heap property. For example the node with the value 9 and the node with the value 8
both violates the max heap property and they are not descendants of each other.

\section*{Exercise 3}
We are gonna use the same approach that we used in the lecture. We will build a max heap from the given array and then we will call
DeleteMax() k many times.

\begin{verbatim}
  int KthLargestElement(A[1..n], k)
    BuildMaxHeap(A)
    for i = 1 to k do
      result = DeleteMax(A)
    return result

  void BuildMaxHeap(A[1..n]) // this is called makeheap() in the lecture slides
    for i = n/2 down to 1 do
      Heapify(A, i) // heapify function from the lecture
\end{verbatim}

\textbf{Running Time Analysis:} \\
Building the max heap takes O(n) time as we saw in the lecture. Each call to DeleteMax() takes O(log n) time. Since we are calling DeleteMax() k many times, this part takes O(k log n) time. Therefore the total running time of the algorithm is
\begin{align*}
  O(n) + O(k \log n) = O(n + k \log n).
\end{align*}

\textbf{Correctness Proof}: \\
The BuildMaxHeap() function builds a valid max heap from the given array A. In a max heap the maximum element is always at the root node. The DeleteMax() function removes and returns the maximum element from the heap and then reestablishes the max heap property by calling Heapify().
So at the time we call DeleteMax() for the kth time we get the kth largest element from the original array A and then we return it.

\end{document}